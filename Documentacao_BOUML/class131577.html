<!-- Documentation produced by the Html generator of Bouml (http://bouml.free.fr) -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Class sqlite3_pcache_methods</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body bgcolor="#ffffff">

<div class = "title">Class sqlite3_pcache_methods</div>
<p></p>

<!-- ============================================================= -->

<a name="refclass131577"></a>
<p><br />	 ** CAPI3REF: Application Defined Page Cache.<br />	 ** EXPERIMENTAL<br />	 **<br />	 ** The [sqlite3_config]([SQLITE_CONFIG_PCACHE], ...) interface can<br />	 ** register an alternative page cache implementation by passing in an<br />	 ** instance of the sqlite3_pcache_methods structure. The majority of the<br />	 ** heap memory used by sqlite is used by the page cache to cache data read<br />	 ** from, or ready to be written to, the database file. By implementing a<br />	 ** custom page cache using this API, an application can control more<br />	 ** precisely the amount of memory consumed by sqlite, the way in which<br />	 ** said memory is allocated and released, and the policies used to<br />	 ** determine exactly which parts of a database file are cached and for<br />	 ** how long.<br />	 **<br />	 ** The contents of the structure are copied to an internal buffer by sqlite<br />	 ** within the call to [sqlite3_config].<br />	 **<br />	 ** The xInit() method is called once for each call to [sqlite3_initialize()]<br />	 ** (usually only once during the lifetime of the process). It is passed<br />	 ** a copy of the sqlite3_pcache_methods.pArg value. It can be used to set<br />	 ** up global structures and mutexes required by the custom page cache<br />	 ** implementation. The xShutdown() method is called from within<br />	 ** [sqlite3_shutdown()], if the application invokes this API. It can be used<br />	 ** to clean up any outstanding resources before process shutdown, if required.<br />	 **<br />	 ** The xCreate() method is used to construct a new cache instance. The<br />	 ** first parameter, szPage, is the size in bytes of the pages that must<br />	 ** be allocated by the cache. szPage will not be a power of two. The<br />	 ** second argument, bPurgeable, is true if the cache being created will<br />	 ** be used to cache database pages read from a file stored on disk, or<br />	 ** false if it is used for an in-memory database. The cache implementation<br />	 ** does not have to do anything special based on the value of bPurgeable,<br />	 ** it is purely advisory.<br />	 **<br />	 ** The xCachesize() method may be called at any time by SQLite to set the<br />	 ** suggested maximum cache-size (number of pages stored by) the cache<br />	 ** instance passed as the first argument. This is the value configured using<br />	 ** the SQLite "[PRAGMA cache_size]" command. As with the bPurgeable parameter,<br />	 ** the implementation is not required to do anything special with this<br />	 ** value, it is advisory only.<br />	 **<br />	 ** The xPagecount() method should return the number of pages currently<br />	 ** stored in the cache supplied as an argument.<br />	 **<br />	 ** The xFetch() method is used to fetch a page and return a pointer to it.<br />	 ** A 'page', in this context, is a buffer of szPage bytes aligned at an<br />	 ** 8-byte boundary. The page to be fetched is determined by the key. The<br />	 ** mimimum key value is 1. After it has been retrieved using xFetch, the page<br />	 ** is considered to be pinned.<br />	 **<br />	 ** If the requested page is already in the page cache, then a pointer to<br />	 ** the cached buffer should be returned with its contents intact. If the<br />	 ** page is not already in the cache, then the expected behaviour of the<br />	 ** cache is determined by the value of the createFlag parameter passed<br />	 ** to xFetch, according to the following table:<br />	 **<br />	 ** &lt;table border=1 width=85% align=center&gt;<br />	 **   &lt;tr&gt;&lt;th&gt;createFlag&lt;th&gt;Expected Behaviour<br />	 **   &lt;tr&gt;&lt;td&gt;0&lt;td&gt;NULL should be returned. No new cache entry is created.<br />	 **   &lt;tr&gt;&lt;td&gt;1&lt;td&gt;If createFlag is set to 1, this indicates that<br />	 **                SQLite is holding pinned pages that can be unpinned<br />	 **                by writing their contents to the database file (a<br />	 **                relatively expensive operation). In this situation the<br />	 **                cache implementation has two choices: it can return NULL,<br />	 **                in which case SQLite will attempt to unpin one or more<br />	 **                pages before re-requesting the same page, or it can<br />	 **                allocate a new page and return a pointer to it. If a new<br />	 **                page is allocated, then the first sizeof(void*) bytes of<br />	 **                it (at least) must be zeroed before it is returned.<br />	 **   &lt;tr&gt;&lt;td&gt;2&lt;td&gt;If createFlag is set to 2, then SQLite is not holding any<br />	 **                pinned pages associated with the specific cache passed<br />	 **                as the first argument to xFetch() that can be unpinned. The<br />	 **                cache implementation should attempt to allocate a new<br />	 **                cache entry and return a pointer to it. Again, the first<br />	 **                sizeof(void*) bytes of the page should be zeroed before<br />	 **                it is returned. If the xFetch() method returns NULL when<br />	 **                createFlag==2, SQLite assumes that a memory allocation<br />	 **                failed and returns SQLITE_NOMEM to the user.<br />	 ** &lt;/table&gt;<br />	 **<br />	 ** xUnpin() is called by SQLite with a pointer to a currently pinned page<br />	 ** as its second argument. If the third parameter, discard, is non-zero,<br />	 ** then the page should be evicted from the cache. In this case SQLite<br />	 ** assumes that the next time the page is retrieved from the cache using<br />	 ** the xFetch() method, it will be zeroed. If the discard parameter is<br />	 ** zero, then the page is considered to be unpinned. The cache implementation<br />	 ** may choose to reclaim (free or recycle) unpinned pages at any time.<br />	 ** SQLite assumes that next time the page is retrieved from the cache<br />	 ** it will either be zeroed, or contain the same data that it did when it<br />	 ** was unpinned.<br />	 **<br />	 ** The cache is not required to perform any reference counting. A single<br />	 ** call to xUnpin() unpins the page regardless of the number of prior calls<br />	 ** to xFetch().<br />	 **<br />	 ** The xRekey() method is used to change the key value associated with the<br />	 ** page passed as the second argument from oldKey to newKey. If the cache<br />	 ** previously contains an entry associated with newKey, it should be<br />	 ** discarded. Any prior cache entry associated with newKey is guaranteed not<br />	 ** to be pinned.<br />	 **<br />	 ** When SQLite calls the xTruncate() method, the cache must discard all<br />	 ** existing cache entries with page numbers (keys) greater than or equal<br />	 ** to the value of the iLimit parameter passed to xTruncate(). If any<br />	 ** of these pages are pinned, they are implicitly unpinned, meaning that<br />	 ** they can be safely discarded.<br />	 **<br />	 ** The xDestroy() method is used to delete a cache allocated by xCreate().<br />	 ** All resources associated with the specified cache should be freed. After<br />	 ** calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]<br />	 ** handle invalid, and will not use it with any other sqlite3_pcache_methods<br />	 ** functions.<br />	 <br /></p><p>Declaration :</p><ul><li>C++ : typedef struct <a href="class131577.html#refclass131577"><b>sqlite3_pcache_methods</b></a> sqlite3_pcache_methods; </li></ul><p>Artifact : <a href="index.html#refartifact128505"><b>sqlite3</b></a></p><p>Stereotype: typedef</p>
<div class="sub">
</div>
</body>
</html>
