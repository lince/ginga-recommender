<!-- Documentation produced by the Html generator of Bouml (http://bouml.free.fr) -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Classes Index</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body bgcolor="#ffffff">

<div class = "title">Classes Index</div>
<p></p>

<!-- ============================================================= -->

<table>
<tr bgcolor=#f0f0f0><td><a href="class128889.html#refclass128889" target = "projectFrame"><b>__int64</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128121.html#refclass128121" target = "projectFrame"><b>AgentListener</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132473.html#refclass132473" target = "projectFrame"><b>Channel</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132729.html#refclass132729" target = "projectFrame"><b>Context</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128377.html#refclass128377" target = "projectFrame"><b>Database</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131961.html#refclass131961" target = "projectFrame"><b>DataMining</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132857.html#refclass132857" target = "projectFrame"><b>Document</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132345.html#refclass132345" target = "projectFrame"><b>eit</b></a></td><td></td><td>*<br />                     * Fornece uma abstração para a tabela Eit. A tabela Eit<br />                     * é responsável em prover informações sobre os serviços<br />                     * disponibilizados pelos provedores de serviços<br />                     *<br />                     * @author Paulo Muniz de Ávila<br />                     </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128249.html#refclass128249" target = "projectFrame"><b>IAgentListener</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134265.html#refclass134265" target = "projectFrame"><b>IMiningAlgorithmApriori</b></a></td><td></td><td>#include &lt;ginga/recommender/database/Database.h&gt;<br />#include &lt;ginga/recommender/utils/Utils.h&gt;<br />#include "MiningAlgorithm.h"<br />#include "apriori23/Apriori_Trie.hpp"<br />#include "apriori23/Apriori.hpp"<br />#include "apriori23/common.hpp"<br />#include "apriori23/Input_Output_Manager.hpp"<br />#include "apriori23/Trie.hpp"<br />#include "SI.h"<br />#include "User.h"</td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134393.html#refclass134393" target = "projectFrame"><b>itemtype</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133113.html#refclass133113" target = "projectFrame"><b>Iteraction</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132601.html#refclass132601" target = "projectFrame"><b>IteractionBase</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133497.html#refclass133497" target = "projectFrame"><b>Key</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133625.html#refclass133625" target = "projectFrame"><b>LocalAgent</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133881.html#refclass133881" target = "projectFrame"><b>Media</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134009.html#refclass134009" target = "projectFrame"><b>Meta</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132217.html#refclass132217" target = "projectFrame"><b>MiningAlgorithm</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132089.html#refclass132089" target = "projectFrame"><b>MiningAlgoritmKeys</b></a></td><td>enum</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class132985.html#refclass132985" target = "projectFrame"><b>NclStateMachine</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133241.html#refclass133241" target = "projectFrame"><b>Program</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134777.html#refclass134777" target = "projectFrame"><b>Scheduler</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134905.html#refclass134905" target = "projectFrame"><b>SchedulerItem</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134649.html#refclass134649" target = "projectFrame"><b>sdt</b></a></td><td></td><td>*<br />                     * Criar um abstração para a tabela sdt responsável em informar o nome<br />                     * do provedor de serviços e o serviço associado<br />                     *<br />                     * @author Paulo Muniz de Ávila<br />                     </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134521.html#refclass134521" target = "projectFrame"><b>si</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128505.html#refclass128505" target = "projectFrame"><b>sqlite3</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Database Connection Handle {H12000} &lt;S40200&gt;<br />	 ** KEYWORDS: {database connection} {database connections}<br />	 **<br />	 ** Each open SQLite database is represented by a pointer to an instance of<br />	 ** the opaque structure named "sqlite3".  It is useful to think of an sqlite3<br />	 ** pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and<br />	 ** [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]<br />	 ** is its destructor.  There are many other interfaces (such as<br />	 ** [sqlite3_prepare_v2()], [sqlite3_create_function()], and<br />	 ** [sqlite3_busy_timeout()] to name but three) that are methods on an<br />	 ** sqlite3 object.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131833.html#refclass131833" target = "projectFrame"><b>sqlite3_api_routines</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131705.html#refclass131705" target = "projectFrame"><b>sqlite3_backup</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Online Backup Object<br />	 ** EXPERIMENTAL<br />	 **<br />	 ** The sqlite3_backup object records state information about an ongoing<br />	 ** online backup operation.  The sqlite3_backup object is created by<br />	 ** a call to [sqlite3_backup_init()] and is destroyed by a call to<br />	 ** [sqlite3_backup_finish()].<br />	 **<br />	 ** See Also: [Using the SQLite Online Backup API]<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131193.html#refclass131193" target = "projectFrame"><b>sqlite3_blob</b></a></td><td>typedef</td><td><br />	 ** The interface to the virtual-table mechanism defined above (back up<br />	 ** to a comment remarkably similar to this one) is currently considered<br />	 ** to be experimental.  The interface might change in incompatible ways.<br />	 ** If this is a problem for you, do not use the interface at this time.<br />	 **<br />	 ** When the virtual-table mechanism stabilizes, we will declare the<br />	 ** interface fixed, support it indefinitely, and remove this comment.<br />	 **<br />	 ****** EXPERIMENTAL - subject to change without notice **************<br />	 <br /><br />	 ** CAPI3REF: A Handle To An Open BLOB {H17800} &lt;S30230&gt;<br />	 ** KEYWORDS: {BLOB handle} {BLOB handles}<br />	 **<br />	 ** An instance of this object represents an open BLOB on which<br />	 ** [sqlite3_blob_open | incremental BLOB I/O] can be performed.<br />	 ** Objects of this type are created by [sqlite3_blob_open()]<br />	 ** and destroyed by [sqlite3_blob_close()].<br />	 ** The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfaces<br />	 ** can be used to read or write small subsections of the BLOB.<br />	 ** The [sqlite3_blob_bytes()] interface returns the size of the BLOB in bytes.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129401.html#refclass129401" target = "projectFrame"><b>sqlite3_callback</b></a></td><td>typedef</td><td><br />	 ** The type for a callback function.<br />	 ** This is legacy and deprecated.  It is included for historical<br />	 ** compatibility and is not documented.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130425.html#refclass130425" target = "projectFrame"><b>sqlite3_context</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: SQL Function Context Object {H16001} &lt;S20200&gt;<br />	 **<br />	 ** The context in which an SQL function executes is stored in an<br />	 ** sqlite3_context object.  A pointer to an sqlite3_context object<br />	 ** is always first parameter to [application-defined SQL functions].<br />	 ** The application-defined SQL function implementation will pass this<br />	 ** pointer through into calls to [sqlite3_result_int | sqlite3_result()],<br />	 ** [sqlite3_aggregate_context()], [sqlite3_user_data()],<br />	 ** [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],<br />	 ** and/or [sqlite3_set_auxdata()].<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130553.html#refclass130553" target = "projectFrame"><b>sqlite3_destructor_type</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Constants Defining Special Destructor Behavior {H10280} &lt;S30100&gt;<br />	 **<br />	 ** These are special values for the destructor that is passed in as the<br />	 ** final argument to routines like [sqlite3_result_blob()].  If the destructor<br />	 ** argument is SQLITE_STATIC, it means that the content pointer is constant<br />	 ** and will never change.  It does not need to be destroyed.  The<br />	 ** SQLITE_TRANSIENT value means that the content will likely change in<br />	 ** the near future and that SQLite should make its own private copy of<br />	 ** the content before returning.<br />	 **<br />	 ** The typedef is necessary to work around problems in certain<br />	 ** C++ compilers.  See ticket #2191.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129529.html#refclass129529" target = "projectFrame"><b>sqlite3_file</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: OS Interface Open File Handle {H11110} &lt;S20110&gt;<br />	 **<br />	 ** An [sqlite3_file] object represents an open file in the OS<br />	 ** interface layer.  Individual OS interface implementations will<br />	 ** want to subclass this object by appending additional fields<br />	 ** for their own use.  The pMethods entry is a pointer to an<br />	 ** [sqlite3_io_methods] object that defines methods for performing<br />	 ** I/O operations on the open file.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130809.html#refclass130809" target = "projectFrame"><b>sqlite3_index_info</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129145.html#refclass129145" target = "projectFrame"><b>sqlite3_int64</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129657.html#refclass129657" target = "projectFrame"><b>sqlite3_io_methods</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: OS Interface File Virtual Methods Object {H11120} &lt;S20110&gt;<br />	 **<br />	 ** Every file opened by the [sqlite3_vfs] xOpen method populates an<br />	 ** [sqlite3_file] object (or, more commonly, a subclass of the<br />	 ** [sqlite3_file] object) with a pointer to an instance of this object.<br />	 ** This object defines the methods used to perform various operations<br />	 ** against the open file represented by the [sqlite3_file] object.<br />	 **<br />	 ** If the xOpen method sets the sqlite3_file.pMethods element<br />	 ** to a non-NULL pointer, then the sqlite3_io_methods.xClose method<br />	 ** may be invoked even if the xOpen reported that it failed.  The<br />	 ** only way to prevent a call to xClose following a failed xOpen<br />	 ** is for the xOpen to set the sqlite3_file.pMethods element to NULL.<br />	 **<br />	 ** The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or<br />	 ** [SQLITE_SYNC_FULL].  The first choice is the normal fsync().<br />	 ** The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]<br />	 ** flag may be ORed in to indicate that only the data of the file<br />	 ** and not its inode needs to be synced.<br />	 **<br />	 ** The integer values to xLock() and xUnlock() are one of<br />	 ** &lt;ul&gt;<br />	 ** &lt;li&gt; [SQLITE_LOCK_NONE],<br />	 ** &lt;li&gt; [SQLITE_LOCK_SHARED],<br />	 ** &lt;li&gt; [SQLITE_LOCK_RESERVED],<br />	 ** &lt;li&gt; [SQLITE_LOCK_PENDING], or<br />	 ** &lt;li&gt; [SQLITE_LOCK_EXCLUSIVE].<br />	 ** &lt;/ul&gt;<br />	 ** xLock() increases the lock. xUnlock() decreases the lock.<br />	 ** The xCheckReservedLock() method checks whether any database connection,<br />	 ** either in this process or in some other process, is holding a RESERVED,<br />	 ** PENDING, or EXCLUSIVE lock on the file.  It returns true<br />	 ** if such a lock exists and false otherwise.<br />	 **<br />	 ** The xFileControl() method is a generic interface that allows custom<br />	 ** VFS implementations to directly control an open file using the<br />	 ** [sqlite3_file_control()] interface.  The second "op" argument is an<br />	 ** integer opcode.  The third argument is a generic pointer intended to<br />	 ** point to a structure that may contain arguments or space in which to<br />	 ** write return values.  Potential uses for xFileControl() might be<br />	 ** functions to enable blocking locks with timeouts, to change the<br />	 ** locking strategy (for example to use dot-file locks), to inquire<br />	 ** about the status of a lock, or to break stale locks.  The SQLite<br />	 ** core reserves all opcodes less than 100 for its own use.<br />	 ** A [SQLITE_FCNTL_LOCKSTATE | list of opcodes] less than 100 is available.<br />	 ** Applications that define a custom xFileControl method should use opcodes<br />	 ** greater than 100 to avoid conflicts.<br />	 **<br />	 ** The xSectorSize() method returns the sector size of the<br />	 ** device that underlies the file.  The sector size is the<br />	 ** minimum write that can be performed without disturbing<br />	 ** other bytes in the file.  The xDeviceCharacteristics()<br />	 ** method returns a bit vector describing behaviors of the<br />	 ** underlying device:<br />	 **<br />	 ** &lt;ul&gt;<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC512]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC1K]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC2K]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC4K]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC8K]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC16K]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC32K]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_ATOMIC64K]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_SAFE_APPEND]<br />	 ** &lt;li&gt; [SQLITE_IOCAP_SEQUENTIAL]<br />	 ** &lt;/ul&gt;<br />	 **<br />	 ** The SQLITE_IOCAP_ATOMIC property means that all writes of<br />	 ** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values<br />	 ** mean that writes of blocks that are nnn bytes in size and<br />	 ** are aligned to an address which is an integer multiple of<br />	 ** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means<br />	 ** that when data is appended to a file, the data is appended<br />	 ** first then the size of the file is extended, never the other<br />	 ** way around.  The SQLITE_IOCAP_SEQUENTIAL property means that<br />	 ** information is written to disk in the same order as calls<br />	 ** to xWrite().<br />	 **<br />	 ** If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill<br />	 ** in the unread portions of the buffer with zeros.  A VFS that<br />	 ** fails to zero-fill short reads might seem to work.  However,<br />	 ** failure to zero-fill short reads will eventually lead to<br />	 ** database corruption.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130041.html#refclass130041" target = "projectFrame"><b>sqlite3_mem_methods</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Memory Allocation Routines {H10155} &lt;S20120&gt;<br />	 ** EXPERIMENTAL<br />	 **<br />	 ** An instance of this object defines the interface between SQLite<br />	 ** and low-level memory allocation routines.<br />	 **<br />	 ** This object is used in only one place in the SQLite interface.<br />	 ** A pointer to an instance of this object is the argument to<br />	 ** [sqlite3_config()] when the configuration option is<br />	 ** [SQLITE_CONFIG_MALLOC].  By creating an instance of this object<br />	 ** and passing it to [sqlite3_config()] during configuration, an<br />	 ** application can specify an alternative memory allocation subsystem<br />	 ** for SQLite to use for all of its dynamic memory needs.<br />	 **<br />	 ** Note that SQLite comes with a built-in memory allocator that is<br />	 ** perfectly adequate for the overwhelming majority of applications<br />	 ** and that this object is only useful to a tiny minority of applications<br />	 ** with specialized memory allocation requirements.  This object is<br />	 ** also used during testing of SQLite in order to specify an alternative<br />	 ** memory allocator that simulates memory out-of-memory conditions in<br />	 ** order to verify that SQLite recovers gracefully from such<br />	 ** conditions.<br />	 **<br />	 ** The xMalloc, xFree, and xRealloc methods must work like the<br />	 ** malloc(), free(), and realloc() functions from the standard library.<br />	 **<br />	 ** xSize should return the allocated size of a memory allocation<br />	 ** previously obtained from xMalloc or xRealloc.  The allocated size<br />	 ** is always at least as big as the requested size but may be larger.<br />	 **<br />	 ** The xRoundup method returns what would be the allocated size of<br />	 ** a memory allocation given a particular requested size.  Most memory<br />	 ** allocators round up memory allocations at least to the next multiple<br />	 ** of 8.  Some allocators round up to a larger multiple or to a power of 2.<br />	 **<br />	 ** The xInit method initializes the memory allocator.  (For example,<br />	 ** it might allocate any require mutexes or initialize internal data<br />	 ** structures.  The xShutdown method is invoked (indirectly) by<br />	 ** [sqlite3_shutdown()] and should deallocate any resources acquired<br />	 ** by xInit.  The pAppData pointer is used as the only parameter to<br />	 ** xInit and xShutdown.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131065.html#refclass131065" target = "projectFrame"><b>sqlite3_module</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129785.html#refclass129785" target = "projectFrame"><b>sqlite3_mutex</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Mutex Handle {H17110} &lt;S20130&gt;<br />	 **<br />	 ** The mutex module within SQLite defines [sqlite3_mutex] to be an<br />	 ** abstract type for a mutex object.  The SQLite core never looks<br />	 ** at the internal representation of an [sqlite3_mutex].  It only<br />	 ** deals with pointers to the [sqlite3_mutex] object.<br />	 **<br />	 ** Mutexes are created using [sqlite3_mutex_alloc()].<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131321.html#refclass131321" target = "projectFrame"><b>sqlite3_mutex_methods</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Mutex Methods Object {H17120} &lt;S20130&gt;<br />	 ** EXPERIMENTAL<br />	 **<br />	 ** An instance of this structure defines the low-level routines<br />	 ** used to allocate and use mutexes.<br />	 **<br />	 ** Usually, the default mutex implementations provided by SQLite are<br />	 ** sufficient, however the user has the option of substituting a custom<br />	 ** implementation for specialized deployments or systems for which SQLite<br />	 ** does not provide a suitable implementation. In this case, the user<br />	 ** creates and populates an instance of this structure to pass<br />	 ** to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.<br />	 ** Additionally, an instance of this structure can be used as an<br />	 ** output variable when querying the system for the current mutex<br />	 ** implementation, using the [SQLITE_CONFIG_GETMUTEX] option.<br />	 **<br />	 ** The xMutexInit method defined by this structure is invoked as<br />	 ** part of system initialization by the sqlite3_initialize() function.<br />	 ** {H17001} The xMutexInit routine shall be called by SQLite once for each<br />	 ** effective call to [sqlite3_initialize()].<br />	 **<br />	 ** The xMutexEnd method defined by this structure is invoked as<br />	 ** part of system shutdown by the sqlite3_shutdown() function. The<br />	 ** implementation of this method is expected to release all outstanding<br />	 ** resources obtained by the mutex methods implementation, especially<br />	 ** those obtained by the xMutexInit method. {H17003} The xMutexEnd()<br />	 ** interface shall be invoked once for each call to [sqlite3_shutdown()].<br />	 **<br />	 ** The remaining seven methods defined by this structure (xMutexAlloc,<br />	 ** xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and<br />	 ** xMutexNotheld) implement the following interfaces (respectively):<br />	 **<br />	 ** &lt;ul&gt;<br />	 **   &lt;li&gt;  [sqlite3_mutex_alloc()] &lt;/li&gt;<br />	 **   &lt;li&gt;  [sqlite3_mutex_free()] &lt;/li&gt;<br />	 **   &lt;li&gt;  [sqlite3_mutex_enter()] &lt;/li&gt;<br />	 **   &lt;li&gt;  [sqlite3_mutex_try()] &lt;/li&gt;<br />	 **   &lt;li&gt;  [sqlite3_mutex_leave()] &lt;/li&gt;<br />	 **   &lt;li&gt;  [sqlite3_mutex_held()] &lt;/li&gt;<br />	 **   &lt;li&gt;  [sqlite3_mutex_notheld()] &lt;/li&gt;<br />	 ** &lt;/ul&gt;<br />	 **<br />	 ** The only difference is that the public sqlite3_XXX functions enumerated<br />	 ** above silently ignore any invocations that pass a NULL pointer instead<br />	 ** of a valid mutex handle. The implementations of the methods defined<br />	 ** by this structure are not required to handle this case, the results<br />	 ** of passing a NULL pointer instead of a valid mutex handle are undefined<br />	 ** (i.e. it is acceptable to provide an implementation that segfaults if<br />	 ** it is passed a NULL pointer).<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131449.html#refclass131449" target = "projectFrame"><b>sqlite3_pcache</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Custom Page Cache Object<br />	 ** EXPERIMENTAL<br />	 **<br />	 ** The sqlite3_pcache type is opaque.  It is implemented by<br />	 ** the pluggable module.  The SQLite core has no knowledge of<br />	 ** its size or internal structure and never deals with the<br />	 ** sqlite3_pcache object except by holding and passing pointers<br />	 ** to the object.<br />	 **<br />	 ** See [sqlite3_pcache_methods] for additional information.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class131577.html#refclass131577" target = "projectFrame"><b>sqlite3_pcache_methods</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Application Defined Page Cache.<br />	 ** EXPERIMENTAL<br />	 **<br />	 ** The [sqlite3_config]([SQLITE_CONFIG_PCACHE], ...) interface can<br />	 ** register an alternative page cache implementation by passing in an<br />	 ** instance of the sqlite3_pcache_methods structure. The majority of the<br />	 ** heap memory used by sqlite is used by the page cache to cache data read<br />	 ** from, or ready to be written to, the database file. By implementing a<br />	 ** custom page cache using this API, an application can control more<br />	 ** precisely the amount of memory consumed by sqlite, the way in which<br />	 ** said memory is allocated and released, and the policies used to<br />	 ** determine exactly which parts of a database file are cached and for<br />	 ** how long.<br />	 **<br />	 ** The contents of the structure are copied to an internal buffer by sqlite<br />	 ** within the call to [sqlite3_config].<br />	 **<br />	 ** The xInit() method is called once for each call to [sqlite3_initialize()]<br />	 ** (usually only once during the lifetime of the process). It is passed<br />	 ** a copy of the sqlite3_pcache_methods.pArg value. It can be used to set<br />	 ** up global structures and mutexes required by the custom page cache<br />	 ** implementation. The xShutdown() method is called from within<br />	 ** [sqlite3_shutdown()], if the application invokes this API. It can be used<br />	 ** to clean up any outstanding resources before process shutdown, if required.<br />	 **<br />	 ** The xCreate() method is used to construct a new cache instance. The<br />	 ** first parameter, szPage, is the size in bytes of the pages that must<br />	 ** be allocated by the cache. szPage will not be a power of two. The<br />	 ** second argument, bPurgeable, is true if the cache being created will<br />	 ** be used to cache database pages read from a file stored on disk, or<br />	 ** false if it is used for an in-memory database. The cache implementation<br />	 ** does not have to do anything special based on the value of bPurgeable,<br />	 ** it is purely advisory.<br />	 **<br />	 ** The xCachesize() method may be called at any time by SQLite to set the<br />	 ** suggested maximum cache-size (number of pages stored by) the cache<br />	 ** instance passed as the first argument. This is the value configured using<br />	 ** the SQLite "[PRAGMA cache_size]" command. As with the bPurgeable parameter,<br />	 ** the implementation is not required to do anything special with this<br />	 ** value, it is advisory only.<br />	 **<br />	 ** The xPagecount() method should return the number of pages currently<br />	 ** stored in the cache supplied as an argument.<br />	 **<br />	 ** The xFetch() method is used to fetch a page and return a pointer to it.<br />	 ** A 'page', in this context, is a buffer of szPage bytes aligned at an<br />	 ** 8-byte boundary. The page to be fetched is determined by the key. The<br />	 ** mimimum key value is 1. After it has been retrieved using xFetch, the page<br />	 ** is considered to be pinned.<br />	 **<br />	 ** If the requested page is already in the page cache, then a pointer to<br />	 ** the cached buffer should be returned with its contents intact. If the<br />	 ** page is not already in the cache, then the expected behaviour of the<br />	 ** cache is determined by the value of the createFlag parameter passed<br />	 ** to xFetch, according to the following table:<br />	 **<br />	 ** &lt;table border=1 width=85% align=center&gt;<br />	 **   &lt;tr&gt;&lt;th&gt;createFlag&lt;th&gt;Expected Behaviour<br />	 **   &lt;tr&gt;&lt;td&gt;0&lt;td&gt;NULL should be returned. No new cache entry is created.<br />	 **   &lt;tr&gt;&lt;td&gt;1&lt;td&gt;If createFlag is set to 1, this indicates that<br />	 **                SQLite is holding pinned pages that can be unpinned<br />	 **                by writing their contents to the database file (a<br />	 **                relatively expensive operation). In this situation the<br />	 **                cache implementation has two choices: it can return NULL,<br />	 **                in which case SQLite will attempt to unpin one or more<br />	 **                pages before re-requesting the same page, or it can<br />	 **                allocate a new page and return a pointer to it. If a new<br />	 **                page is allocated, then the first sizeof(void*) bytes of<br />	 **                it (at least) must be zeroed before it is returned.<br />	 **   &lt;tr&gt;&lt;td&gt;2&lt;td&gt;If createFlag is set to 2, then SQLite is not holding any<br />	 **                pinned pages associated with the specific cache passed<br />	 **                as the first argument to xFetch() that can be unpinned. The<br />	 **                cache implementation should attempt to allocate a new<br />	 **                cache entry and return a pointer to it. Again, the first<br />	 **                sizeof(void*) bytes of the page should be zeroed before<br />	 **                it is returned. If the xFetch() method returns NULL when<br />	 **                createFlag==2, SQLite assumes that a memory allocation<br />	 **                failed and returns SQLITE_NOMEM to the user.<br />	 ** &lt;/table&gt;<br />	 **<br />	 ** xUnpin() is called by SQLite with a pointer to a currently pinned page<br />	 ** as its second argument. If the third parameter, discard, is non-zero,<br />	 ** then the page should be evicted from the cache. In this case SQLite<br />	 ** assumes that the next time the page is retrieved from the cache using<br />	 ** the xFetch() method, it will be zeroed. If the discard parameter is<br />	 ** zero, then the page is considered to be unpinned. The cache implementation<br />	 ** may choose to reclaim (free or recycle) unpinned pages at any time.<br />	 ** SQLite assumes that next time the page is retrieved from the cache<br />	 ** it will either be zeroed, or contain the same data that it did when it<br />	 ** was unpinned.<br />	 **<br />	 ** The cache is not required to perform any reference counting. A single<br />	 ** call to xUnpin() unpins the page regardless of the number of prior calls<br />	 ** to xFetch().<br />	 **<br />	 ** The xRekey() method is used to change the key value associated with the<br />	 ** page passed as the second argument from oldKey to newKey. If the cache<br />	 ** previously contains an entry associated with newKey, it should be<br />	 ** discarded. Any prior cache entry associated with newKey is guaranteed not<br />	 ** to be pinned.<br />	 **<br />	 ** When SQLite calls the xTruncate() method, the cache must discard all<br />	 ** existing cache entries with page numbers (keys) greater than or equal<br />	 ** to the value of the iLimit parameter passed to xTruncate(). If any<br />	 ** of these pages are pinned, they are implicitly unpinned, meaning that<br />	 ** they can be safely discarded.<br />	 **<br />	 ** The xDestroy() method is used to delete a cache allocated by xCreate().<br />	 ** All resources associated with the specified cache should be freed. After<br />	 ** calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]<br />	 ** handle invalid, and will not use it with any other sqlite3_pcache_methods<br />	 ** functions.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130169.html#refclass130169" target = "projectFrame"><b>sqlite3_stmt</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: SQL Statement Object {H13000} &lt;H13010&gt;<br />	 ** KEYWORDS: {prepared statement} {prepared statements}<br />	 **<br />	 ** An instance of this object represents a single SQL statement.<br />	 ** This object is variously known as a "prepared statement" or a<br />	 ** "compiled SQL statement" or simply as a "statement".<br />	 **<br />	 ** The life of a statement object goes something like this:<br />	 **<br />	 ** &lt;ol&gt;<br />	 ** &lt;li&gt; Create the object using [sqlite3_prepare_v2()] or a related<br />	 **      function.<br />	 ** &lt;li&gt; Bind values to [host parameters] using the sqlite3_bind_*()<br />	 **      interfaces.<br />	 ** &lt;li&gt; Run the SQL by calling [sqlite3_step()] one or more times.<br />	 ** &lt;li&gt; Reset the statement using [sqlite3_reset()] then go back<br />	 **      to step 2.  Do this zero or more times.<br />	 ** &lt;li&gt; Destroy the object using [sqlite3_finalize()].<br />	 ** &lt;/ol&gt;<br />	 **<br />	 ** Refer to documentation on individual methods above for additional<br />	 ** information.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129273.html#refclass129273" target = "projectFrame"><b>sqlite3_uint64</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130297.html#refclass130297" target = "projectFrame"><b>sqlite3_value</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: Dynamically Typed Value Object {H15000} &lt;S20200&gt;<br />	 ** KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}<br />	 **<br />	 ** SQLite uses the sqlite3_value object to represent all values<br />	 ** that can be stored in a database table. SQLite uses dynamic typing<br />	 ** for the values it stores. Values stored in sqlite3_value objects<br />	 ** can be integers, floating point values, strings, BLOBs, or NULL.<br />	 **<br />	 ** An sqlite3_value object may be either "protected" or "unprotected".<br />	 ** Some interfaces require a protected sqlite3_value.  Other interfaces<br />	 ** will accept either a protected or an unprotected sqlite3_value.<br />	 ** Every interface that accepts sqlite3_value arguments specifies<br />	 ** whether or not it requires a protected sqlite3_value.<br />	 **<br />	 ** The terms "protected" and "unprotected" refer to whether or not<br />	 ** a mutex is held.  A internal mutex is held for a protected<br />	 ** sqlite3_value object but no mutex is held for an unprotected<br />	 ** sqlite3_value object.  If SQLite is compiled to be single-threaded<br />	 ** (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)<br />	 ** or if SQLite is run in one of reduced mutex modes<br />	 ** [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]<br />	 ** then there is no distinction between protected and unprotected<br />	 ** sqlite3_value objects and they can be used interchangeably.  However,<br />	 ** for maximum code portability it is recommended that applications<br />	 ** still make the distinction between between protected and unprotected<br />	 ** sqlite3_value objects even when not strictly required.<br />	 **<br />	 ** The sqlite3_value objects that are passed as parameters into the<br />	 ** implementation of [application-defined SQL functions] are protected.<br />	 ** The sqlite3_value object returned by<br />	 ** [sqlite3_column_value()] is unprotected.<br />	 ** Unprotected sqlite3_value objects may only be used with<br />	 ** [sqlite3_result_value()] and [sqlite3_bind_value()].<br />	 ** The [sqlite3_value_blob | sqlite3_value_type()] family of<br />	 ** interfaces require protected sqlite3_value objects.<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129913.html#refclass129913" target = "projectFrame"><b>sqlite3_vfs</b></a></td><td>typedef</td><td><br />	 ** CAPI3REF: OS Interface Object {H11140} &lt;S20100&gt;<br />	 **<br />	 ** An instance of the sqlite3_vfs object defines the interface between<br />	 ** the SQLite core and the underlying operating system.  The "vfs"<br />	 ** in the name of the object stands for "virtual file system".<br />	 **<br />	 ** The value of the iVersion field is initially 1 but may be larger in<br />	 ** future versions of SQLite.  Additional fields may be appended to this<br />	 ** object when the iVersion value is increased.  Note that the structure<br />	 ** of the sqlite3_vfs object changes in the transaction between<br />	 ** SQLite version 3.5.9 and 3.6.0 and yet the iVersion field was not<br />	 ** modified.<br />	 **<br />	 ** The szOsFile field is the size of the subclassed [sqlite3_file]<br />	 ** structure used by this VFS.  mxPathname is the maximum length of<br />	 ** a pathname in this VFS.<br />	 **<br />	 ** Registered sqlite3_vfs objects are kept on a linked list formed by<br />	 ** the pNext pointer.  The [sqlite3_vfs_register()]<br />	 ** and [sqlite3_vfs_unregister()] interfaces manage this list<br />	 ** in a thread-safe way.  The [sqlite3_vfs_find()] interface<br />	 ** searches the list.  Neither the application code nor the VFS<br />	 ** implementation should use the pNext pointer.<br />	 **<br />	 ** The pNext field is the only field in the sqlite3_vfs<br />	 ** structure that SQLite will ever modify.  SQLite will only access<br />	 ** or modify this field while holding a particular static mutex.<br />	 ** The application should never modify anything within the sqlite3_vfs<br />	 ** object once the object has been registered.<br />	 **<br />	 ** The zName field holds the name of the VFS module.  The name must<br />	 ** be unique across all VFS modules.<br />	 **<br />	 ** SQLite will guarantee that the zFilename parameter to xOpen<br />	 ** is either a NULL pointer or string obtained<br />	 ** from xFullPathname().  SQLite further guarantees that<br />	 ** the string will be valid and unchanged until xClose() is<br />	 ** called. Because of the previous sentence,<br />	 ** the [sqlite3_file] can safely store a pointer to the<br />	 ** filename if it needs to remember the filename for some reason.<br />	 ** If the zFilename parameter is xOpen is a NULL pointer then xOpen<br />	 ** must invent its own temporary name for the file.  Whenever the<br />	 ** xFilename parameter is NULL it will also be the case that the<br />	 ** flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].<br />	 **<br />	 ** The flags argument to xOpen() includes all bits set in<br />	 ** the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]<br />	 ** or [sqlite3_open16()] is used, then flags includes at least<br />	 ** [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].<br />	 ** If xOpen() opens a file read-only then it sets *pOutFlags to<br />	 ** include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.<br />	 **<br />	 ** SQLite will also add one of the following flags to the xOpen()<br />	 ** call, depending on the object being opened:<br />	 **<br />	 ** &lt;ul&gt;<br />	 ** &lt;li&gt;  [SQLITE_OPEN_MAIN_DB]<br />	 ** &lt;li&gt;  [SQLITE_OPEN_MAIN_JOURNAL]<br />	 ** &lt;li&gt;  [SQLITE_OPEN_TEMP_DB]<br />	 ** &lt;li&gt;  [SQLITE_OPEN_TEMP_JOURNAL]<br />	 ** &lt;li&gt;  [SQLITE_OPEN_TRANSIENT_DB]<br />	 ** &lt;li&gt;  [SQLITE_OPEN_SUBJOURNAL]<br />	 ** &lt;li&gt;  [SQLITE_OPEN_MASTER_JOURNAL]<br />	 ** &lt;/ul&gt;<br />	 **<br />	 ** The file I/O implementation can use the object type flags to<br />	 ** change the way it deals with files.  For example, an application<br />	 ** that does not care about crash recovery or rollback might make<br />	 ** the open of a journal file a no-op.  Writes to this journal would<br />	 ** also be no-ops, and any attempt to read the journal would return<br />	 ** SQLITE_IOERR.  Or the implementation might recognize that a database<br />	 ** file will be doing page-aligned sector reads and writes in a random<br />	 ** order and set up its I/O subsystem accordingly.<br />	 **<br />	 ** SQLite might also add one of the following flags to the xOpen method:<br />	 **<br />	 ** &lt;ul&gt;<br />	 ** &lt;li&gt; [SQLITE_OPEN_DELETEONCLOSE]<br />	 ** &lt;li&gt; [SQLITE_OPEN_EXCLUSIVE]<br />	 ** &lt;/ul&gt;<br />	 **<br />	 ** The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be<br />	 ** deleted when it is closed.  The [SQLITE_OPEN_DELETEONCLOSE]<br />	 ** will be set for TEMP  databases, journals and for subjournals.<br />	 **<br />	 ** The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction<br />	 ** with the [SQLITE_OPEN_CREATE] flag, which are both directly<br />	 ** analogous to the O_EXCL and O_CREAT flags of the POSIX open()<br />	 ** API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the<br />	 ** SQLITE_OPEN_CREATE, is used to indicate that file should always<br />	 ** be created, and that it is an error if it already exists.<br />	 ** It is &lt;i&gt;not&lt;/i&gt; used to indicate the file should be opened<br />	 ** for exclusive access.<br />	 **<br />	 ** At least szOsFile bytes of memory are allocated by SQLite<br />	 ** to hold the  [sqlite3_file] structure passed as the third<br />	 ** argument to xOpen.  The xOpen method does not have to<br />	 ** allocate the structure; it should just fill it in.  Note that<br />	 ** the xOpen method must set the sqlite3_file.pMethods to either<br />	 ** a valid [sqlite3_io_methods] object or to NULL.  xOpen must do<br />	 ** this even if the open fails.  SQLite expects that the sqlite3_file.pMethods<br />	 ** element will be valid after xOpen returns regardless of the success<br />	 ** or failure of the xOpen call.<br />	 **<br />	 ** The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]<br />	 ** to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to<br />	 ** test whether a file is readable and writable, or [SQLITE_ACCESS_READ]<br />	 ** to test whether a file is at least readable.   The file can be a<br />	 ** directory.<br />	 **<br />	 ** SQLite will always allocate at least mxPathname+1 bytes for the<br />	 ** output buffer xFullPathname.  The exact size of the output buffer<br />	 ** is also passed as a parameter to both  methods. If the output buffer<br />	 ** is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is<br />	 ** handled as a fatal error by SQLite, vfs implementations should endeavor<br />	 ** to prevent this by setting mxPathname to a sufficiently large value.<br />	 **<br />	 ** The xRandomness(), xSleep(), and xCurrentTime() interfaces<br />	 ** are not strictly a part of the filesystem, but they are<br />	 ** included in the VFS structure for completeness.<br />	 ** The xRandomness() function attempts to return nBytes bytes<br />	 ** of good-quality randomness into zOut.  The return value is<br />	 ** the actual number of bytes of randomness obtained.<br />	 ** The xSleep() method causes the calling thread to sleep for at<br />	 ** least the number of microseconds given.  The xCurrentTime()<br />	 ** method returns a Julian Day Number for the current date and time.<br />	 **<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130681.html#refclass130681" target = "projectFrame"><b>sqlite3_vtab</b></a></td><td>typedef</td><td><br />	 ****** EXPERIMENTAL - subject to change without notice **************<br />	 **<br />	 ** The interface to the virtual-table mechanism is currently considered<br />	 ** to be experimental.  The interface might change in incompatible ways.<br />	 ** If this is a problem for you, do not use the interface at this time.<br />	 **<br />	 ** When the virtual-table mechanism stabilizes, we will declare the<br />	 ** interface fixed, support it indefinitely, and remove this comment.<br />	 <br /><br />	 ** Structures used by the virtual table interface<br />	 </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class130937.html#refclass130937" target = "projectFrame"><b>sqlite3_vtab_cursor</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128761.html#refclass128761" target = "projectFrame"><b>sqlite_int64</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class128633.html#refclass128633" target = "projectFrame"><b>SQLITE_INT64_TYPE</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class129017.html#refclass129017" target = "projectFrame"><b>sqlite_uint64</b></a></td><td>typedef</td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135033.html#refclass135033" target = "projectFrame"><b>SystemResource</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133753.html#refclass133753" target = "projectFrame"><b>Thread</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class134137.html#refclass134137" target = "projectFrame"><b>User</b></a></td><td></td><td></td></tr>
<tr bgcolor=#f0f0f0><td><a href="class135161.html#refclass135161" target = "projectFrame"><b>Utilitario</b></a></td><td></td><td>*<br />            * Fornecer suporte de conversões e operações com datas<br />            * @author Paulo Muniz de Ávila<br />            </td></tr>
<tr bgcolor=#f0f0f0><td><a href="class133369.html#refclass133369" target = "projectFrame"><b>Volume</b></a></td><td></td><td></td></tr>
</table>
</body>
</html>
